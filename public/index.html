<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Client-Only Photo Signer & Verifier</title>
  <style>
    :root {
      --bg: #0b0f14; --panel:#121822; --muted:#2a3443; --text:#e8eef8; --acc:#5aa2ff; --ok:#27c93f; --warn:#ffbd2e; --err:#ff5f56;
    }
    html, body { height:100%; }
    body { margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, 'Helvetica Neue', Arial, Noto Sans, 'Apple Color Emoji','Segoe UI Emoji'; background:var(--bg); color:var(--text); }
    header { padding: 16px; background: #0d1420; border-bottom:1px solid var(--muted); display:flex; align-items:center; justify-content:space-between; }
    header h1 { margin:0; font-size: 18px; letter-spacing: .2px; }
    header .host { opacity:.7; font-size:12px; }
    main { display:grid; grid-template-columns: 260px 1fr; height: calc(100% - 64px); }
    nav { border-right:1px solid var(--muted); padding: 12px; background: var(--panel); }
    nav button { width:100%; margin:6px 0; padding:10px 12px; background:#162033; color:var(--text); border:1px solid var(--muted); border-radius:8px; cursor:pointer; text-align:left; }
    nav button.active { background:#1b2740; border-color:#2f3c55; }
    section { padding: 16px; overflow:auto; }
    .card { background: var(--panel); border:1px solid var(--muted); border-radius:10px; padding: 12px; margin-bottom: 12px; }
    h2 { font-size: 16px; margin: 0 0 8px 0; }
    h3 { font-size: 14px; margin: 12px 0 6px; opacity:.9 }
    label { display:block; margin: 8px 0 4px; font-size: 12px; opacity:.9; }
    input[type="text"], input[type="password"], select, textarea { width:100%; box-sizing:border-box; padding: 8px; border-radius:8px; border:1px solid var(--muted); background:#0f1624; color:var(--text); }
    input[type="file"] { margin-top:6px; }
    .row { display:flex; gap:10px; align-items:flex-end; flex-wrap:wrap; }
    .row > * { flex:1 1 200px; }
    .btn { background:#1c2a45; color:var(--text); border:1px solid var(--muted); border-radius:8px; padding: 8px 12px; cursor:pointer; }
    .btn:disabled { opacity:.5; cursor:not-allowed; }
    .btn.primary { background: #163a6c; border-color:#2a5688; }
    .btn.ok { background:#0f3; color:#021; }
    .btn.warn { background:#ffbd2e; color:#231; }
    .btn.err { background:#ff5f56; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; font-size:12px; }
    .grid { display:grid; grid-template-columns: repeat(auto-fit, minmax(240px, 1fr)); gap:10px; }
    canvas, video, img { max-width:100%; background:#000; border-radius:8px; border:1px solid var(--muted); }
    details { margin-top:8px; }
    .muted { opacity:.7; }
    .pill { display:inline-block; padding:2px 8px; border:1px solid var(--muted); border-radius:999px; font-size:11px; margin-left:8px; }
    .kvl li { margin:2px 0; }
    .foot { font-size:12px; opacity:.7; margin-top:12px; }
  </style>
</head>
<body>
<header>
  <h1>Client-Only Photo Signer & Verifier <span class="pill">Ed25519 / P-256</span> <span class="pill">No backend</span></h1>
  <div class="host">Deploy: upload this file to GitHub Pages</div>
</header>
<main>
  <nav>
    <button data-tab="identities" class="active">Identities</button>
    <button data-tab="contacts">Contacts</button>
    <button data-tab="capture">Capture & Sign</button>
    <button data-tab="verify">Verify</button>
    <button data-tab="backup">Backup</button>
    <hr style="border-color:var(--muted); opacity:.5">
    <button data-tab="about">About</button>
  </nav>
  <section id="identities" class="tab">
    <div class="card">
      <h2>New Identity</h2>
      <div class="row">
        <div>
          <label>Display name</label>
          <input id="id-name" type="text" placeholder="e.g., Alice Photographer" />
        </div>
        <div>
          <label>Algorithm</label>
          <select id="id-algo">
            <option value="Ed25519" selected>Ed25519 (preferred)</option>
            <option value="P-256">P-256 (ECDSA)</option>
          </select>
        </div>
        <div>
          <label>Passphrase (encrypt private key export)</label>
          <input id="id-pass" type="password" placeholder="Optional (recommended for export)" />
        </div>
      </div>
      <div style="margin-top:8px">
        <button class="btn primary" id="btn-create-id">Create Identity</button>
      </div>
    </div>

    <div class="card">
      <h2>My Identities</h2>
      <div id="identity-list" class="grid"></div>
    </div>

    <div class="card">
      <h2>Import Private Identity</h2>
      <p class="muted">Paste an encrypted private JWK export produced by this app. Decrypts with your passphrase.</p>
      <label>Encrypted Export (JSON)</label>
      <textarea id="id-import-json" rows="6" class="mono" placeholder='{"name":"...","algo":"Ed25519", ...}'></textarea>
      <label>Passphrase</label>
      <input id="id-import-pass" type="password" />
      <div style="margin-top:8px">
        <button class="btn" id="btn-import-id">Import</button>
      </div>
    </div>
  </section>

  <section id="contacts" class="tab" style="display:none">
    <div class="card">
      <h2>New Contact</h2>
      <div class="row">
        <div>
          <label>Display name</label>
          <input id="contact-name" type="text" />
        </div>
        <div>
          <label>Algorithm</label>
          <select id="contact-algo">
            <option value="Ed25519" selected>Ed25519</option>
            <option value="P-256">P-256</option>
          </select>
        </div>
      </div>
      <label>Public Key (Base64URL or JWK)</label>
      <textarea id="contact-pub" rows="3" class="mono" placeholder="Base64URL raw key OR JWK JSON"></textarea>
      <div style="margin-top:8px"><button class="btn" id="btn-add-contact">Add Contact</button></div>
    </div>

    <div class="card">
      <h2>Scan Contact QR</h2>
      <div class="row">
        <div style="flex:2">
          <video id="qr-video" playsinline muted></video>
        </div>
        <div style="flex:1">
          <button class="btn" id="btn-start-scan">Start Camera</button>
          <button class="btn" id="btn-stop-scan">Stop</button>
          <div id="scan-status" class="foot">Idle</div>
        </div>
      </div>
    </div>

    <div class="card">
      <h2>Contacts</h2>
      <div id="contact-list" class="grid"></div>
    </div>
  </section>

  <section id="capture" class="tab" style="display:none">
    <div class="card">
      <h2>Capture / Load Image</h2>
      <div class="row">
        <div><input type="file" id="file-input" accept="image/*" /></div>
        <div><button class="btn" id="btn-open-camera">Use Camera</button></div>
        <div>
          <label>QR Corner</label>
          <select id="qr-corner">
            <option>TR</option><option>TL</option><option>BR</option><option>BL</option>
          </select>
        </div>
        <div>
          <label>QR Size (% of short side)</label>
          <input id="qr-size" type="text" value="15" />
        </div>
      </div>
      <div class="grid">
        <div>
          <h3>Preview</h3>
          <canvas id="canvas" width="640" height="480"></canvas>
          <div class="foot">The QR is placed after signing; hashing uses a black square at the same position.</div>
        </div>
        <div>
          <h3>Camera</h3>
          <video id="cam" autoplay playsinline style="max-height:360px"></video><br/>
          <button class="btn" id="btn-capture">Capture Frame</button>
          <div id="capture-status" class="foot">No camera</div>
        </div>
      </div>
    </div>

    <div class="card">
      <h2>Sign</h2>
      <div class="row">
        <div>
          <label>Signer Identity</label>
          <select id="sign-identity"></select>
        </div>
        <div>
          <label>Optional note</label>
          <input id="sign-note" type="text" placeholder="Short note" />
        </div>
      </div>
      <div style="margin-top:8px">
        <button class="btn primary" id="btn-sign">Hash + Sign + Embed QR</button>
        <button class="btn" id="btn-download">Download PNG</button>
      </div>
      <details>
        <summary>Signature payload</summary>
        <pre id="payload-view" class="mono"></pre>
      </details>
      <details>
        <summary>Verification report (self-check)</summary>
        <pre id="self-verify" class="mono"></pre>
      </details>
    </div>
  </section>

  <section id="verify" class="tab" style="display:none">
    <div class="card">
      <h2>Verify Image</h2>
      <div class="row">
        <div><input type="file" id="verify-file" accept="image/*" /></div>
        <div><input type="text" id="verify-url" placeholder="https://example.com/image.png (CORS required)" /></div>
        <div><button class="btn" id="btn-verify-url">Fetch & Verify</button></div>
      </div>
      <div class="grid">
        <div>
          <h3>Image</h3>
          <canvas id="verify-canvas" width="640" height="480"></canvas>
        </div>
        <div>
          <h3>Result</h3>
          <pre id="verify-report" class="mono"></pre>
        </div>
      </div>
    </div>
  </section>

  <section id="backup" class="tab" style="display:none">
    <div class="card">
      <h2>Backup / Restore</h2>
      <div class="row">
        <div>
          <label>Export Passphrase (for private keys)</label>
          <input id="backup-pass" type="password" />
        </div>
      </div>
      <div style="margin-top:8px">
        <button class="btn" id="btn-backup">Export Backup JSON</button>
      </div>
      <h3>Restore</h3>
      <textarea id="restore-json" rows="8" class="mono" placeholder="Paste backup JSON"></textarea>
      <label>Restore Passphrase</label>
      <input id="restore-pass" type="password" />
      <div style="margin-top:8px">
        <button class="btn" id="btn-restore">Restore</button>
      </div>
    </div>
  </section>

  <section id="about" class="tab" style="display:none">
    <div class="card">
      <h2>About</h2>
      <p>This single-file SPA implements a client-only photo signing and verification workflow: local identities, deterministic hashing with a blackened QR region, QR embedding, and verification.</p>
      <ul class="kvl">
        <li>Keys: Ed25519 (preferred) via WebCrypto, with P-256 fallback; @noble/ed25519 as optional fallback.</li>
        <li>QR: generated client-side; read via jsQR.</li>
        <li>Storage: IndexedDB via localForage.</li>
        <li>No build step. Deploy this <code>index.html</code> on GitHub Pages.</li>
      </ul>
      <p class="foot">Security note: Private keys are stored locally (browser storage). Use strong passphrases and dedicated profiles/devices for sensitive use.</p>
    </div>
  </section>
</main>

<!-- Dependencies via CDN (no build step) -->
<script src="https://cdn.jsdelivr.net/npm/localforage@1.10.0/dist/localforage.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.js"></script>
<script src="https://cdn.jsdelivr.net/npm/qrcode@1.5.3/build/qrcode.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@noble/ed25519@2.1.0/lib/index.umd.min.js"></script>

<script>
  // ---------- Utilities ----------
  const $ = (sel) => document.querySelector(sel);
  const $$ = (sel) => Array.from(document.querySelectorAll(sel));
  const enc = new TextEncoder();
  const dec = new TextDecoder();

  function b64u(buf) {
    const b = Array.isArray(buf) ? new Uint8Array(buf) : new Uint8Array(buf);
    let str = '';
    for (let i=0;i<b.length;i++) str += String.fromCharCode(b[i]);
    return btoa(str).replace(/\+/g,'-').replace(/\//g,'_').replace(/=+$/,'');
  }
  function b64uToBytes(s) {
    s = s.replace(/-/g,'+').replace(/_/g,'/');
    const pad = s.length % 4 === 2 ? '==': s.length % 4 === 3 ? '=' : '';
    const bin = atob(s + pad);
    const out = new Uint8Array(bin.length);
    for (let i=0;i<bin.length;i++) out[i] = bin.charCodeAt(i);
    return out;
  }
  function hex(buf) { return [...new Uint8Array(buf)].map(x=>x.toString(16).padStart(2,'0')).join(''); }

  async function sha256(bytes) {
    const h = await crypto.subtle.digest('SHA-256', bytes);
    return new Uint8Array(h);
  }

  function downloadBlob(name, blob) {
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = name; a.click();
    setTimeout(()=>URL.revokeObjectURL(url), 2000);
  }

  // ---------- Storage (IndexedDB via localForage) ----------
  const db = {
    ids: localforage.createInstance({ name:'photo-signer', storeName:'identities' }),
    contacts: localforage.createInstance({ name:'photo-signer', storeName:'contacts' }),
    captures: localforage.createInstance({ name:'photo-signer', storeName:'captures' }),
  };

  async function listAll(store) {
    const items = [];
    await store.iterate((value, key) => { items.push({ key, value }); });
    return items;
  }

  // ---------- Crypto: WebCrypto + noble fallback ----------
  const hasEd25519 = (() => {
    // Some browsers expose Ed25519 behind subtle.sign({name:'Ed25519'})
    try {
      // Not reliable to feature-detect synchronously; we'll try during keygen.
      return true;
    } catch { return false; }
  })();

  async function importPubKey(algo, rawOrJwk) {
    if (typeof rawOrJwk === 'string') {
      try { rawOrJwk = JSON.parse(rawOrJwk); } catch {}
    }
    if (algo === 'Ed25519') {
      if (rawOrJwk.kty === 'OKP' && rawOrJwk.crv === 'Ed25519' && rawOrJwk.x) {
        const raw = b64uToBytes(rawOrJwk.x);
        try {
          return await crypto.subtle.importKey('raw', raw, { name:'Ed25519' }, true, ['verify']);
        } catch (e) {
          // Will use noble in verify path if WebCrypto import fails.
          return { noble:true, algo:'Ed25519', raw };
        }
      } else {
        const raw = typeof rawOrJwk === 'string' ? b64uToBytes(rawOrJwk) : new Uint8Array(rawOrJwk);
        try { return await crypto.subtle.importKey('raw', raw, { name:'Ed25519' }, true, ['verify']); }
        catch { return { noble:true, algo:'Ed25519', raw }; }
      }
    } else if (algo === 'P-256') {
      if (rawOrJwk.kty) {
        return await crypto.subtle.importKey('jwk', rawOrJwk, { name:'ECDSA', namedCurve:'P-256' }, true, ['verify']);
      } else {
        // raw (x||y) uncompressed not standardized for import in WebCrypto; prefer JWK
        throw new Error('Provide P-256 public key as JWK');
      }
    }
    throw new Error('Unsupported algo');
  }

  async function genKey(algo) {
    if (algo === 'Ed25519') {
      try {
        const key = await crypto.subtle.generateKey({ name:'Ed25519', namedCurve:'Ed25519' }, true, ['sign','verify']);
        const pubRaw = new Uint8Array(await crypto.subtle.exportKey('raw', key.publicKey));
        const pubJwk = await crypto.subtle.exportKey('jwk', key.publicKey);
        return { algo, key, pubRaw, pubJwk };
      } catch (e) {
        // Fallback: noble for Ed25519
        const priv = nobleEd25519.utils.randomPrivateKey();
        const pubRaw = await nobleEd25519.getPublicKeyAsync(priv);
        return { algo, noble:true, priv, pubRaw, pubJwk: { kty:'OKP', crv:'Ed25519', x: b64u(pubRaw) } };
      }
    } else if (algo === 'P-256') {
      const key = await crypto.subtle.generateKey({ name:'ECDSA', namedCurve:'P-256' }, true, ['sign','verify']);
      const pubJwk = await crypto.subtle.exportKey('jwk', key.publicKey);
      // Deriving raw (x) for convenience
      const x = pubJwk.x; // base64url
      return { algo, key, pubRaw: b64uToBytes(x), pubJwk };
    }
    throw new Error('Unsupported algo');
  }

  async function exportPrivateEncrypted(idRec, passphrase) {
    const salt = crypto.getRandomValues(new Uint8Array(16));
    const iv = crypto.getRandomValues(new Uint8Array(12));
    const keyMat = await crypto.subtle.importKey('raw', enc.encode(passphrase || ''), 'PBKDF2', false, ['deriveKey']);
    const aesKey = await crypto.subtle.deriveKey({ name:'PBKDF2', salt, iterations: 200_000, hash:'SHA-256' }, keyMat, { name:'AES-GCM', length:256 }, false, ['encrypt']);

    let privBytes, privJwk;
    if (idRec.noble) {
      privBytes = idRec.priv;
      privJwk = { kty:'OKP', crv:'Ed25519', d: b64u(privBytes), x: b64u(idRec.pubRaw) };
    } else {
      privJwk = await crypto.subtle.exportKey('jwk', idRec.key.privateKey);
      privBytes = enc.encode(JSON.stringify(privJwk));
    }
    const plaintext = idRec.noble ? enc.encode(JSON.stringify(privJwk)) : privBytes;
    const ciphertext = new Uint8Array(await crypto.subtle.encrypt({ name:'AES-GCM', iv }, aesKey, plaintext));
    return {
      name: idRec.name,
      algo: idRec.algo,
      salt: b64u(salt), iv: b64u(iv), ct: b64u(ciphertext)
    };
  }

  async function importPrivateEncrypted(payload, passphrase) {
    const salt = b64uToBytes(payload.salt); const iv = b64uToBytes(payload.iv); const ct = b64uToBytes(payload.ct);
    const keyMat = await crypto.subtle.importKey('raw', enc.encode(passphrase || ''), 'PBKDF2', false, ['deriveKey']);
    const aesKey = await crypto.subtle.deriveKey({ name:'PBKDF2', salt, iterations: 200_000, hash:'SHA-256' }, keyMat, { name:'AES-GCM', length:256 }, false, ['decrypt']);
    const plain = new Uint8Array(await crypto.subtle.decrypt({ name:'AES-GCM', iv }, aesKey, ct));
    const jwk = JSON.parse(dec.decode(plain));
    if (payload.algo === 'Ed25519') {
      try {
        const priv = await crypto.subtle.importKey('jwk', jwk, { name:'Ed25519', namedCurve:'Ed25519' }, true, ['sign']);
        const pub = await crypto.subtle.importKey('jwk', { kty:'OKP', crv:'Ed25519', x:jwk.x }, { name:'Ed25519' }, true, ['verify']);
        const pubRaw = new Uint8Array(await crypto.subtle.exportKey('raw', pub));
        return { name: payload.name, algo:'Ed25519', key: { privateKey: priv, publicKey: pub }, pubRaw, pubJwk: { kty:'OKP', crv:'Ed25519', x:jwk.x } };
      } catch (e) {
        // noble path
        const priv = b64uToBytes(jwk.d);
        const pubRaw = await nobleEd25519.getPublicKeyAsync(priv);
        return { name: payload.name, algo:'Ed25519', noble:true, priv, pubRaw, pubJwk:{ kty:'OKP', crv:'Ed25519', x:b64u(pubRaw) } };
      }
    } else if (payload.algo === 'P-256') {
      const priv = await crypto.subtle.importKey('jwk', jwk, { name:'ECDSA', namedCurve:'P-256' }, true, ['sign']);
      const pub = await crypto.subtle.importKey('jwk', { ...jwk, d: undefined }, { name:'ECDSA', namedCurve:'P-256' }, true, ['verify']);
      const pubJwk = await crypto.subtle.exportKey('jwk', pub);
      return { name: payload.name, algo:'P-256', key: { privateKey: priv, publicKey: pub }, pubRaw: b64uToBytes(pubJwk.x), pubJwk };
    }
    throw new Error('Unsupported');
  }

  async function signBytes(idRec, bytes) {
    if (idRec.algo === 'Ed25519') {
      if (idRec.noble) {
        const sig = await nobleEd25519.signAsync(bytes, idRec.priv);
        return new Uint8Array(sig);
      } else {
        const sig = await crypto.subtle.sign({ name:'Ed25519' }, idRec.key.privateKey, bytes);
        return new Uint8Array(sig);
      }
    } else if (idRec.algo === 'P-256') {
      const sig = await crypto.subtle.sign({ name:'ECDSA', hash: 'SHA-256' }, idRec.key.privateKey, bytes);
      return new Uint8Array(sig); // DER
    }
    throw new Error('Unsupported algo');
  }

  async function verifySig(algo, pubKey, bytes, sig) {
    if (algo === 'Ed25519') {
      if (pubKey && pubKey.noble) {
        return await nobleEd25519.verifyAsync(sig, bytes, pubKey.raw);
      }
      try {
        return await crypto.subtle.verify({ name:'Ed25519' }, pubKey, sig, bytes);
      } catch (e) {
        // Try noble if pubKey is raw wrapper
        if (pubKey && pubKey.raw) return await nobleEd25519.verifyAsync(sig, bytes, pubKey.raw);
        throw e;
      }
    } else if (algo === 'P-256') {
      return await crypto.subtle.verify({ name:'ECDSA', hash:'SHA-256' }, pubKey, sig, bytes);
    }
    throw new Error('Unsupported algo');
  }

  // ---------- UI Tabs ----------
  const tabs = $$('.tab');
  $$('#root nav button, nav button').forEach(btn => btn.addEventListener('click', () => switchTab(btn.dataset.tab)));
  function switchTab(id) {
    $$('#root .active, nav button.active').forEach(el=>el.classList.remove('active'));
    $(`nav button[data-tab="${id}"]`).classList.add('active');
    tabs.forEach(t => t.style.display = (t.id === id ? '' : 'none'));
  }

  // ---------- Identity management ----------
  async function refreshIdentities() {
    const list = await listAll(db.ids);
    const cont = $('#identity-list'); cont.innerHTML = '';
    const sel = $('#sign-identity'); sel.innerHTML = '';
    list.forEach(({key, value}) => {
      const div = document.createElement('div');
      div.className='card';
      div.innerHTML = `
        <div><strong>${value.name}</strong> <span class="pill">${value.algo}</span></div>
        <div class="mono muted">pk: ${b64u(value.pubRaw)}</div>
        <div style="margin-top:6px" class="row">
          <button class="btn" data-export="${key}">Export Private (encrypted)</button>
          <button class="btn warn" data-del="${key}">Delete</button>
        </div>
      `;
      cont.appendChild(div);
      const opt = document.createElement('option');
      opt.value = key; opt.textContent = `${value.name} (${value.algo})`;
      sel.appendChild(opt);
    });
    if (!list.length) {
      $('#identity-list').innerHTML = '<div class="muted">No identities yet.</div>';
    }
  }

  $('#btn-create-id').addEventListener('click', async () => {
    const name = $('#id-name').value.trim() || 'Unnamed';
    const algo = $('#id-algo').value;
    const k = await genKey(algo);
    const rec = { name, algo, ...k };
    const id = crypto.randomUUID();
    await db.ids.setItem(id, rec);
    await refreshIdentities();
    alert('Identity created');
  });

  $('#identity-list').addEventListener('click', async (e) => {
    const t = e.target;
    if (t.dataset.export) {
      const id = t.dataset.export; const rec = await db.ids.getItem(id);
      const pass = $('#id-pass').value || prompt('Passphrase to encrypt private key export:');
      if (!pass) return;
      const payload = await exportPrivateEncrypted(rec, pass);
      const blob = new Blob([JSON.stringify(payload, null, 2)], { type:'application/json' });
      downloadBlob(`identity-${rec.name}.priv.enc.json`, blob);
    } else if (t.dataset.del) {
      if (!confirm('Delete identity?')) return;
      await db.ids.removeItem(t.dataset.del);
      await refreshIdentities();
    }
  });

  $('#btn-import-id').addEventListener('click', async () => {
    try {
      const json = JSON.parse($('#id-import-json').value);
      const pass = $('#id-import-pass').value;
      const rec = await importPrivateEncrypted(json, pass);
      const id = crypto.randomUUID();
      await db.ids.setItem(id, rec);
      await refreshIdentities();
      alert('Imported identity');
    } catch (e) { alert('Import failed: ' + e.message); }
  });

  // ---------- Contacts ----------
  async function refreshContacts() {
    const list = await listAll(db.contacts);
    const cont = $('#contact-list'); cont.innerHTML='';
    list.forEach(({key, value}) => {
      const div = document.createElement('div');
      div.className='card';
      div.innerHTML = `
        <div><strong>${value.displayName}</strong> <span class="pill">${value.algo}</span></div>
        <div class="mono muted">pk: ${typeof value.publicJwk === 'string' ? value.publicJwk : (value.publicJwk.x || JSON.stringify(value.publicJwk))}</div>
        <div style="margin-top:6px" class="row">
          <button class="btn warn" data-del="${key}">Delete</button>
        </div>
      `;
      cont.appendChild(div);
    });
    if (!list.length) cont.innerHTML = '<div class="muted">No contacts yet.</div>';
  }

  $('#btn-add-contact').addEventListener('click', async () => {
    const displayName = $('#contact-name').value.trim();
    const algo = $('#contact-algo').value;
    let publicJwk = $('#contact-pub').value.trim();
    try { publicJwk = JSON.parse(publicJwk); } catch {}
    const id = crypto.randomUUID();
    await db.contacts.setItem(id, { displayName, algo, publicJwk });
    await refreshContacts();
    alert('Contact saved');
  });

  $('#contact-list').addEventListener('click', async (e) => {
    const t = e.target;
    if (t.dataset.del) { await db.contacts.removeItem(t.dataset.del); await refreshContacts(); }
  });

  // QR scanning for contacts (expects JSON {displayName, algo, publicJwk|raw})
  let scanTimer; let stream;
  $('#btn-start-scan').addEventListener('click', async () => {
    const video = $('#qr-video');
    stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode:'environment' } });
    video.srcObject = stream; await video.play();
    $('#scan-status').textContent = 'Scanning...';
    const canvas = document.createElement('canvas'); const ctx = canvas.getContext('2d');
    scanTimer = setInterval(async () => {
      canvas.width = video.videoWidth; canvas.height = video.videoHeight;
      ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
      const img = ctx.getImageData(0,0,canvas.width, canvas.height);
      const code = jsQR(img.data, img.width, img.height);
      if (code) {
        try {
          const obj = JSON.parse(code.data);
          const id = crypto.randomUUID();
          await db.contacts.setItem(id, obj);
          await refreshContacts();
          $('#scan-status').textContent = 'Contact added';
          clearInterval(scanTimer); scanTimer=null; if (stream) stream.getTracks().forEach(t=>t.stop());
        } catch { $('#scan-status').textContent = 'Invalid QR'; }
      }
    }, 300);
  });
  $('#btn-stop-scan').addEventListener('click', () => { if (scanTimer){clearInterval(scanTimer); scanTimer=null;} if (stream){stream.getTracks().forEach(t=>t.stop());} $('#scan-status').textContent='Idle'; });

  // ---------- Imaging helpers ----------
  function drawToCanvas(img, canvas) {
    const ctx = canvas.getContext('2d');
    const maxW = 1600, maxH = 1600; // modest cap to keep memory sane
    let w = img.naturalWidth || img.videoWidth || img.width; let h = img.naturalHeight || img.videoHeight || img.height;
    const scale = Math.min(1, maxW/w, maxH/h);
    w = Math.max(1, Math.round(w*scale)); h = Math.max(1, Math.round(h*scale));
    canvas.width = w; canvas.height = h;
    ctx.drawImage(img, 0, 0, w, h);
  }

  function placeRect(w, h, percent, corner) {
    const s = Math.round(Math.min(w, h) * (percent/100));
    const pad = Math.round(s * 0.08); // quiet zone around QR
    const size = s; // QR drawn inside, with its own quiet zone
    let x = 0, y = 0;
    if (corner === 'TR') { x = w - size - pad; y = pad; }
    if (corner === 'TL') { x = pad; y = pad; }
    if (corner === 'BR') { x = w - size - pad; y = h - size - pad; }
    if (corner === 'BL') { x = pad; y = h - size - pad; }
    return { x, y, size };
  }

  async function canvasToPngBytes(canvas) {
    const url = canvas.toDataURL('image/png');
    const bin = atob(url.split(',')[1]);
    const bytes = new Uint8Array(bin.length);
    for (let i=0;i<bin.length;i++) bytes[i] = bin.charCodeAt(i);
    return bytes;
  }

  async function computeHashWithBlackSquare(imgCanvas, corner, percent) {
    // Copy, draw black square, export PNG bytes, sha256
    const c = document.createElement('canvas'); c.width = imgCanvas.width; c.height = imgCanvas.height;
    const ctx = c.getContext('2d'); ctx.drawImage(imgCanvas, 0, 0);
    const r = placeRect(c.width, c.height, percent, corner);
    ctx.fillStyle = '#000'; ctx.fillRect(r.x, r.y, r.size, r.size);
    const bytes = await canvasToPngBytes(c);
    return { hash: await sha256(bytes), bytes, rect:r };
  }

  async function drawQR(canvas, text, rect) {
    // Render QR on temp canvas, then draw onto main
    const temp = document.createElement('canvas');
    temp.width = rect.size; temp.height = rect.size;
    await QRCode.toCanvas(temp, text, { errorCorrectionLevel:'M', margin:1, width: rect.size });
    const ctx = canvas.getContext('2d');
    ctx.drawImage(temp, rect.x, rect.y);
  }

  // ---------- Capture/Sign flow ----------
  let currentCanvas = $('#canvas');
  let currentImageBytes = null;

  $('#file-input').addEventListener('change', async (e) => {
    const f = e.target.files[0]; if (!f) return;
    const img = new Image(); img.onload = () => { drawToCanvas(img, currentCanvas); }; img.src = URL.createObjectURL(f);
  });

  let camStream;
  $('#btn-open-camera').addEventListener('click', async () => {
    try {
      camStream = await navigator.mediaDevices.getUserMedia({ video: { facingMode:'environment' }, audio:false });
      const v = $('#cam'); v.srcObject = camStream; await v.play();
      $('#capture-status').textContent = 'Camera ready';
    } catch (e) { $('#capture-status').textContent = 'Camera error: ' + e.message; }
  });

  $('#btn-capture').addEventListener('click', async () => {
    const v = $('#cam'); if (!v.srcObject) return;
    drawToCanvas(v, currentCanvas);
  });

  async function getSelectedIdentity() {
    const id = $('#sign-identity').value; if (!id) throw new Error('No identity selected');
    const rec = await db.ids.getItem(id); if (!rec) throw new Error('Identity not found');
    return { id, rec };
  }

  $('#btn-sign').addEventListener('click', async () => {
    try {
      const { id, rec } = await getSelectedIdentity();
      const corner = $('#qr-corner').value; const percent = parseFloat($('#qr-size').value);
      // Compute hash over PNG bytes with black square
      const { hash, rect } = await computeHashWithBlackSquare(currentCanvas, corner, percent);
      const payload = {
        version: 1,
        algo: rec.algo,
        imageHash: b64u(hash),
        signerPub: b64u(rec.pubRaw),
        timestamp: new Date().toISOString(),
        corner,
        percent,
        optional: { note: $('#sign-note').value || undefined }
      };
      const payloadBytes = enc.encode(JSON.stringify(payload));
      const sig = await signBytes(rec, payloadBytes);

      // Draw QR with compact JSON (payload+sig)
      const token = JSON.stringify({ v:1, alg:payload.algo, pk:payload.signerPub, ts:payload.timestamp, ih:payload.imageHash, c:payload.corner, p:payload.percent, sig:b64u(sig) });
      await drawQR(currentCanvas, token, rect);

      // Self-verify and show
      const ok = await verifyFromCanvas(currentCanvas);
      $('#payload-view').textContent = JSON.stringify(payload, null, 2) + "\n\nSignature (b64u):\n" + b64u(sig);
      $('#self-verify').textContent = JSON.stringify(ok, null, 2);
      alert('Signed and QR embedded');
    } catch (e) { alert('Sign failed: ' + e.message); }
  });

  $('#btn-download').addEventListener('click', async () => {
    const bytes = await canvasToPngBytes(currentCanvas);
    downloadBlob('signed.png', new Blob([bytes], { type:'image/png' }));
  });

  // ---------- Verification ----------
  async function verifyFromCanvas(canvas) {
    // 1) scan QR
    const ctx = canvas.getContext('2d');
    const img = ctx.getImageData(0,0,canvas.width, canvas.height);
    const code = jsQR(img.data, img.width, img.height);
    if (!code) return { verified:false, reason:'No QR found' };
    let token; try { token = JSON.parse(code.data); } catch { return { verified:false, reason:'QR not JSON' }; }
    const { v, alg, pk, ts, ih, c, p, sig } = token;
    // 2) recompute hash with black square
    const { hash } = await computeHashWithBlackSquare(canvas, c, p);
    const hashB64 = b64u(hash);
    // 3) rebuild payload (same structure as sign)
    const payload = { version:1, algo:alg, imageHash:hashB64, signerPub:pk, timestamp:ts, corner:c, percent:p };
    const payloadBytes = enc.encode(JSON.stringify(payload));
    // 4) verify sig
    let pub;
    try { pub = await importPubKey(alg, { kty:'OKP', crv:'Ed25519', x: pk }); }
    catch { try { pub = await importPubKey(alg, pk); } catch (e) { pub = { noble:true, raw: b64uToBytes(pk) }; }
    const ok = await verifySig(alg, pub, payloadBytes, b64uToBytes(sig));

    return {
      verified: ok && (hashB64 === ih),
      reason: ok ? (hashB64===ih? 'OK':'Hash mismatch') : 'Bad signature',
      details: { alg, publicKey: pk, timestamp: ts, imageHashComputed: hashB64, imageHashQR: ih }
    };
  }

  async function drawBytesToCanvas(bytes, canvas) {
    return new Promise((resolve,reject)=>{
      const blob = new Blob([bytes], { type:'image/png' });
      const url = URL.createObjectURL(blob);
      const img = new Image(); img.onload = () => { drawToCanvas(img, canvas); URL.revokeObjectURL(url); resolve(); };
      img.onerror = (e)=>{ URL.revokeObjectURL(url); reject(e); };
      img.src = url;
    });
  }

  $('#verify-file').addEventListener('change', async (e) => {
    const f = e.target.files[0]; if (!f) return;
    const img = new Image(); img.onload = async () => { drawToCanvas(img, $('#verify-canvas')); const rep = await verifyFromCanvas($('#verify-canvas')); $('#verify-report').textContent = JSON.stringify(rep, null, 2); };
    img.src = URL.createObjectURL(f);
  });

  $('#btn-verify-url').addEventListener('click', async () => {
    const url = $('#verify-url').value.trim(); if (!url) return;
    try {
      const res = await fetch(url, { mode:'cors' });
      if (!res.ok) throw new Error('HTTP ' + res.status);
      const buf = new Uint8Array(await res.arrayBuffer());
      await drawBytesToCanvas(buf, $('#verify-canvas'));
      const rep = await verifyFromCanvas($('#verify-canvas'));
      $('#verify-report').textContent = JSON.stringify(rep, null, 2);
    } catch (e) {
      $('#verify-report').textContent = JSON.stringify({ verified:false, reason:'Fetch failed or CORS blocked', error:e.message }, null, 2);
    }
  });

  // ---------- Backup/Restore ----------
  $('#btn-backup').addEventListener('click', async () => {
    const pass = $('#backup-pass').value || prompt('Passphrase to encrypt private keys in backup:');
    const ids = await listAll(db.ids);
    const contacts = await listAll(db.contacts);
    const out = { version:1, when:new Date().toISOString(), identities:[], contacts: contacts.map(x=>x.value) };
    for (const { value } of ids) out.identities.push(await exportPrivateEncrypted(value, pass));
    downloadBlob('photosigner-backup.json', new Blob([JSON.stringify(out, null, 2)], { type:'application/json' }));
  });

  $('#btn-restore').addEventListener('click', async () => {
    try {
      const json = JSON.parse($('#restore-json').value);
      const pass = $('#restore-pass').value || prompt('Backup passphrase:');
      if (json.contacts) {
        for (const c of json.contacts) await db.contacts.setItem(crypto.randomUUID(), c);
      }
      if (json.identities) {
        for (const i of json.identities) {
          const rec = await importPrivateEncrypted(i, pass);
          await db.ids.setItem(crypto.randomUUID(), rec);
        }
      }
      await refreshIdentities(); await refreshContacts();
      alert('Restore complete');
    } catch (e) { alert('Restore failed: '+e.message); }
  });

  // ---------- Init ----------
  (async function init(){
    await refreshIdentities(); await refreshContacts();
  })();
</script>

</body>
</html>
